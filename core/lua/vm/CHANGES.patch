diff --git a/core/luavm/lauxlib.c b/core/luavm/lauxlib.c
index 923105ed..466e55bc 100644
--- a/core/luavm/lauxlib.c
+++ b/core/luavm/lauxlib.c
@@ -7,6 +7,8 @@
 #define lauxlib_c
 #define LUA_LIB
 
+#include "../internal.h"
+
 #include "lprefix.h"
 
 
@@ -711,7 +713,7 @@ LUALIB_API void luaL_unref (lua_State *L, int t, int ref) {
 
 typedef struct LoadF {
   int n;  /* number of pre-read characters */
-  FILE *f;  /* file being read */
+  nux_u32_t slot;
   char buff[BUFSIZ];  /* area for reading file */
 } LoadF;
 
@@ -727,8 +729,9 @@ static const char *getF (lua_State *L, void *ud, size_t *size) {
     /* 'fread' can return > 0 *and* set the EOF flag. If next call to
        'getF' called 'fread', it might still wait for user input.
        The next check avoids this problem. */
-    if (feof(lf->f)) return NULL;
-    *size = fread(lf->buff, 1, sizeof(lf->buff), lf->f);  /* read block */
+    // if (feof(lf->f)) return NULL;
+    nux_ctx_t *ctx = lua_getuserdata(L);
+    *size = nux_io_read(ctx, lf->slot, lf->buff, sizeof(lf->buff));
   }
   return lf->buff;
 }
@@ -745,80 +748,24 @@ static int errfile (lua_State *L, const char *what, int fnameindex) {
   return LUA_ERRFILE;
 }
 
-
-/*
-** Skip an optional BOM at the start of a stream. If there is an
-** incomplete BOM (the first character is correct but the rest is
-** not), returns the first character anyway to force an error
-** (as no chunk can start with 0xEF).
-*/
-static int skipBOM (FILE *f) {
-  int c = getc(f);  /* read first character */
-  if (c == 0xEF && getc(f) == 0xBB && getc(f) == 0xBF)  /* correct BOM? */
-    return getc(f);  /* ignore BOM and return next char */
-  else  /* no (valid) BOM */
-    return c;  /* return first character */
-}
-
-
-/*
-** reads the first character of file 'f' and skips an optional BOM mark
-** in its beginning plus its first line if it starts with '#'. Returns
-** true if it skipped the first line.  In any case, '*cp' has the
-** first "valid" character of the file (after the optional BOM and
-** a first-line comment).
-*/
-static int skipcomment (FILE *f, int *cp) {
-  int c = *cp = skipBOM(f);
-  if (c == '#') {  /* first line is a comment (Unix exec. file)? */
-    do {  /* skip first line */
-      c = getc(f);
-    } while (c != EOF && c != '\n');
-    *cp = getc(f);  /* next character after comment, if present */
-    return 1;  /* there was a comment */
-  }
-  else return 0;  /* no comment */
-}
-
-
 LUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,
                                              const char *mode) {
   LoadF lf;
-  int status, readstatus;
-  int c;
+  int status;
+  nux_status_t readstatus;
   int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */
-  if (filename == NULL) {
-    lua_pushliteral(L, "=stdin");
-    lf.f = stdin;
-  }
-  else {
+  nux_ctx_t *ctx = lua_getuserdata(L);
+  lf.slot = NUX_NULL;
+  if (filename != NULL) {
     lua_pushfstring(L, "@%s", filename);
     errno = 0;
-    lf.f = fopen(filename, "r");
-    if (lf.f == NULL) return errfile(L, "open", fnameindex);
+    lf.slot = nux_io_open(ctx, filename);
   }
+  if (lf.slot == NUX_NULL) return errfile(L, "open", fnameindex);
   lf.n = 0;
-  if (skipcomment(lf.f, &c))  /* read initial portion */
-    lf.buff[lf.n++] = '\n';  /* add newline to correct line numbers */
-  if (c == LUA_SIGNATURE[0]) {  /* binary file? */
-    lf.n = 0;  /* remove possible newline */
-    if (filename) {  /* "real" file? */
-      errno = 0;
-      lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
-      if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
-      skipcomment(lf.f, &c);  /* re-read initial portion */
-    }
-  }
-  if (c != EOF)
-    lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */
   errno = 0;
   status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);
-  readstatus = ferror(lf.f);
-  if (filename) fclose(lf.f);  /* close file (even in case of errors) */
-  if (readstatus) {
-    lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */
-    return errfile(L, "read", fnameindex);
-  }
+  if (filename) nux_io_close(ctx, lf.slot);  /* close file (even in case of errors) */
   lua_remove(L, fnameindex);
   return status;
 }
@@ -1100,13 +1047,14 @@ static void warnfcont (void *ud, const char *message, int tocont) {
 static void warnfon (void *ud, const char *message, int tocont) {
   if (checkcontrol((lua_State *)ud, message, tocont))  /* control message? */
     return;  /* nothing else to be done */
+  lua_State *L = ud;
   lua_writestringerror("%s", "Lua warning: ");  /* start a new warning */
   warnfcont(ud, message, tocont);  /* finish processing */
 }
 
 
-LUALIB_API lua_State *luaL_newstate (void) {
-  lua_State *L = lua_newstate(l_alloc, NULL);
+LUALIB_API lua_State *luaL_newstate (void *ud) {
+  lua_State *L = lua_newstate(l_alloc, ud);
   if (l_likely(L)) {
     lua_atpanic(L, &panic);
     lua_setwarnf(L, warnfoff, L);  /* default is warnings off */
diff --git a/core/luavm/lauxlib.h b/core/luavm/lauxlib.h
index 5b977e2a..4d5afc69 100644
--- a/core/luavm/lauxlib.h
+++ b/core/luavm/lauxlib.h
@@ -8,7 +8,6 @@
 #ifndef lauxlib_h
 #define lauxlib_h
 
-
 #include <stddef.h>
 #include <stdio.h>
 
@@ -98,7 +97,7 @@ LUALIB_API int (luaL_loadbufferx) (lua_State *L, const char *buff, size_t sz,
                                    const char *name, const char *mode);
 LUALIB_API int (luaL_loadstring) (lua_State *L, const char *s);
 
-LUALIB_API lua_State *(luaL_newstate) (void);
+LUALIB_API lua_State *(luaL_newstate) (void *ud);
 
 LUALIB_API lua_Integer (luaL_len) (lua_State *L, int idx);
 
@@ -257,18 +256,18 @@ typedef struct luaL_Stream {
 
 /* print a string */
 #if !defined(lua_writestring)
-#define lua_writestring(s,l)   fwrite((s), sizeof(char), (l), stdout)
+#define lua_writestring(s,l)   nux_log(lua_getuserdata(L), NUX_LOG_INFO, "%.*s", (l), (s))
 #endif
 
 /* print a newline and flush the output */
 #if !defined(lua_writeline)
-#define lua_writeline()        (lua_writestring("\n", 1), fflush(stdout))
+#define lua_writeline()        (lua_writestring("\n", 1))
 #endif
 
 /* print an error message */
 #if !defined(lua_writestringerror)
 #define lua_writestringerror(s,p) \
-        (fprintf(stderr, (s), (p)), fflush(stderr))
+        (nux_log(lua_getuserdata(L), NUX_LOG_ERROR, "%.*s", (s), (p)))
 #endif
 
 /* }================================================================== */
diff --git a/core/luavm/lbaselib.c b/core/luavm/lbaselib.c
index 1d60c9de..6a5ba83e 100644
--- a/core/luavm/lbaselib.c
+++ b/core/luavm/lbaselib.c
@@ -7,6 +7,7 @@
 #define lbaselib_c
 #define LUA_LIB
 
+#include "../internal.h"
 #include "lprefix.h"
 
 
@@ -32,7 +33,6 @@ static int luaB_print (lua_State *L) {
     lua_writestring(s, l);  /* print it */
     lua_pop(L, 1);  /* pop result */
   }
-  lua_writeline();
   return 0;
 }
 
diff --git a/core/luavm/ldblib.c b/core/luavm/ldblib.c
index 6dcbaa98..77567368 100644
--- a/core/luavm/ldblib.c
+++ b/core/luavm/ldblib.c
@@ -7,6 +7,7 @@
 #define ldblib_c
 #define LUA_LIB
 
+#include "../internal.h"
 #include "lprefix.h"
 
 
diff --git a/core/luavm/linit.c b/core/luavm/linit.c
index 69808f84..fd39ea76 100644
--- a/core/luavm/linit.c
+++ b/core/luavm/linit.c
@@ -44,8 +44,8 @@ static const luaL_Reg loadedlibs[] = {
   {LUA_LOADLIBNAME, luaopen_package},
   {LUA_COLIBNAME, luaopen_coroutine},
   {LUA_TABLIBNAME, luaopen_table},
-  {LUA_IOLIBNAME, luaopen_io},
-  {LUA_OSLIBNAME, luaopen_os},
+  // {LUA_IOLIBNAME, luaopen_io},
+  // {LUA_OSLIBNAME, luaopen_os},
   {LUA_STRLIBNAME, luaopen_string},
   {LUA_MATHLIBNAME, luaopen_math},
   {LUA_UTF8LIBNAME, luaopen_utf8},
diff --git a/core/luavm/lmathlib.c b/core/luavm/lmathlib.c
index 43810634..8d08efcc 100644
--- a/core/luavm/lmathlib.c
+++ b/core/luavm/lmathlib.c
@@ -7,6 +7,8 @@
 #define lmathlib_c
 #define LUA_LIB
 
+#include "../internal.h"
+
 #include "lprefix.h"
 
 
@@ -14,7 +16,6 @@
 #include <limits.h>
 #include <math.h>
 #include <stdlib.h>
-#include <time.h>
 
 #include "lua.h"
 
@@ -626,7 +627,7 @@ static void setseed (lua_State *L, Rand64 *state,
 ** randomization).
 */
 static void randseed (lua_State *L, RanState *state) {
-  lua_Unsigned seed1 = (lua_Unsigned)time(NULL);
+  lua_Unsigned seed1 = (lua_Unsigned)nux_random(lua_getuserdata(L));
   lua_Unsigned seed2 = (lua_Unsigned)(size_t)L;
   setseed(L, state->s, seed1, seed2);
 }
diff --git a/core/luavm/loadlib.c b/core/luavm/loadlib.c
index 6d289fce..6d21c190 100644
--- a/core/luavm/loadlib.c
+++ b/core/luavm/loadlib.c
@@ -11,6 +11,8 @@
 #define loadlib_c
 #define LUA_LIB
 
+#include "../internal.h"
+
 #include "lprefix.h"
 
 
@@ -30,10 +32,6 @@
 ** LUA_LSUBSEP is the character that replaces dots in submodule names
 ** when searching for a Lua loader.
 */
-#if !defined(LUA_CSUBSEP)
-#define LUA_CSUBSEP		LUA_DIRSEP
-#endif
-
 #if !defined(LUA_LSUBSEP)
 #define LUA_LSUBSEP		LUA_DIRSEP
 #endif
@@ -50,8 +48,6 @@
 ** key for table in the registry that keeps handles
 ** for all loaded C libraries
 */
-static const char *const CLIBS = "_CLIBS";
-
 #define LIB_FAIL	"open"
 
 
@@ -74,23 +70,6 @@ typedef void (*voidf)(void);
 */
 static void lsys_unloadlib (void *lib);
 
-/*
-** load C library in file 'path'. If 'seeglb', load with all names in
-** the library global.
-** Returns the library; in case of error, returns NULL plus an
-** error string in the stack.
-*/
-static void *lsys_load (lua_State *L, const char *path, int seeglb);
-
-/*
-** Try to find a function named 'sym' in library 'lib'.
-** Returns the function; in case of error, returns NULL plus an
-** error string in the stack.
-*/
-static lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym);
-
-
-
 
 #if defined(LUA_USE_DLOPEN)	/* { */
 /*
@@ -256,164 +235,22 @@ static lua_CFunction lsys_sym (lua_State *L, void *lib, const char *sym) {
 ** ===================================================================
 */
 
-/*
-** LUA_PATH_VAR and LUA_CPATH_VAR are the names of the environment
-** variables that Lua check to set its paths.
-*/
-#if !defined(LUA_PATH_VAR)
-#define LUA_PATH_VAR    "LUA_PATH"
-#endif
-
-#if !defined(LUA_CPATH_VAR)
-#define LUA_CPATH_VAR   "LUA_CPATH"
-#endif
-
-
-
-/*
-** return registry.LUA_NOENV as a boolean
-*/
-static int noenv (lua_State *L) {
-  int b;
-  lua_getfield(L, LUA_REGISTRYINDEX, "LUA_NOENV");
-  b = lua_toboolean(L, -1);
-  lua_pop(L, 1);  /* remove value */
-  return b;
-}
-
 
 /*
 ** Set a path
 */
 static void setpath (lua_State *L, const char *fieldname,
-                                   const char *envname,
                                    const char *dft) {
   const char *dftmark;
-  const char *nver = lua_pushfstring(L, "%s%s", envname, LUA_VERSUFFIX);
-  const char *path = getenv(nver);  /* try versioned name */
-  if (path == NULL)  /* no versioned environment variable? */
-    path = getenv(envname);  /* try unversioned name */
-  if (path == NULL || noenv(L))  /* no environment variable? */
-    lua_pushstring(L, dft);  /* use default */
-  else if ((dftmark = strstr(path, LUA_PATH_SEP LUA_PATH_SEP)) == NULL)
-    lua_pushstring(L, path);  /* nothing to change */
-  else {  /* path contains a ";;": insert default path in its place */
-    size_t len = strlen(path);
-    luaL_Buffer b;
-    luaL_buffinit(L, &b);
-    if (path < dftmark) {  /* is there a prefix before ';;'? */
-      luaL_addlstring(&b, path, dftmark - path);  /* add it */
-      luaL_addchar(&b, *LUA_PATH_SEP);
-    }
-    luaL_addstring(&b, dft);  /* add default */
-    if (dftmark < path + len - 2) {  /* is there a suffix after ';;'? */
-      luaL_addchar(&b, *LUA_PATH_SEP);
-      luaL_addlstring(&b, dftmark + 2, (path + len - 2) - dftmark);
-    }
-    luaL_pushresult(&b);
-  }
+  lua_pushstring(L, dft);  /* use default */
   setprogdir(L);
-  lua_setfield(L, -3, fieldname);  /* package[fieldname] = path value */
-  lua_pop(L, 1);  /* pop versioned variable name ('nver') */
+  lua_setfield(L, -2, fieldname);  /* package[fieldname] = path value */
 }
 
 /* }================================================================== */
 
 
-/*
-** return registry.CLIBS[path]
-*/
-static void *checkclib (lua_State *L, const char *path) {
-  void *plib;
-  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
-  lua_getfield(L, -1, path);
-  plib = lua_touserdata(L, -1);  /* plib = CLIBS[path] */
-  lua_pop(L, 2);  /* pop CLIBS table and 'plib' */
-  return plib;
-}
-
-
-/*
-** registry.CLIBS[path] = plib        -- for queries
-** registry.CLIBS[#CLIBS + 1] = plib  -- also keep a list of all libraries
-*/
-static void addtoclib (lua_State *L, const char *path, void *plib) {
-  lua_getfield(L, LUA_REGISTRYINDEX, CLIBS);
-  lua_pushlightuserdata(L, plib);
-  lua_pushvalue(L, -1);
-  lua_setfield(L, -3, path);  /* CLIBS[path] = plib */
-  lua_rawseti(L, -2, luaL_len(L, -2) + 1);  /* CLIBS[#CLIBS + 1] = plib */
-  lua_pop(L, 1);  /* pop CLIBS table */
-}
-
-
-/*
-** __gc tag method for CLIBS table: calls 'lsys_unloadlib' for all lib
-** handles in list CLIBS
-*/
-static int gctm (lua_State *L) {
-  lua_Integer n = luaL_len(L, 1);
-  for (; n >= 1; n--) {  /* for each handle, in reverse order */
-    lua_rawgeti(L, 1, n);  /* get handle CLIBS[n] */
-    lsys_unloadlib(lua_touserdata(L, -1));
-    lua_pop(L, 1);  /* pop handle */
-  }
-  return 0;
-}
-
-
-
 /* error codes for 'lookforfunc' */
-#define ERRLIB		1
-#define ERRFUNC		2
-
-/*
-** Look for a C function named 'sym' in a dynamically loaded library
-** 'path'.
-** First, check whether the library is already loaded; if not, try
-** to load it.
-** Then, if 'sym' is '*', return true (as library has been loaded).
-** Otherwise, look for symbol 'sym' in the library and push a
-** C function with that symbol.
-** Return 0 and 'true' or a function in the stack; in case of
-** errors, return an error code and an error message in the stack.
-*/
-static int lookforfunc (lua_State *L, const char *path, const char *sym) {
-  void *reg = checkclib(L, path);  /* check loaded C libraries */
-  if (reg == NULL) {  /* must load library? */
-    reg = lsys_load(L, path, *sym == '*');  /* global symbols if 'sym'=='*' */
-    if (reg == NULL) return ERRLIB;  /* unable to load library */
-    addtoclib(L, path, reg);
-  }
-  if (*sym == '*') {  /* loading only library (no function)? */
-    lua_pushboolean(L, 1);  /* return 'true' */
-    return 0;  /* no errors */
-  }
-  else {
-    lua_CFunction f = lsys_sym(L, reg, sym);
-    if (f == NULL)
-      return ERRFUNC;  /* unable to find function */
-    lua_pushcfunction(L, f);  /* else create new function */
-    return 0;  /* no errors */
-  }
-}
-
-
-static int ll_loadlib (lua_State *L) {
-  const char *path = luaL_checkstring(L, 1);
-  const char *init = luaL_checkstring(L, 2);
-  int stat = lookforfunc(L, path, init);
-  if (l_likely(stat == 0))  /* no errors? */
-    return 1;  /* return the loaded function */
-  else {  /* error; error message is on stack top */
-    luaL_pushfail(L);
-    lua_insert(L, -2);
-    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : "init");
-    return 3;  /* return fail, error message, and where */
-  }
-}
-
-
 
 /*
 ** {======================================================
@@ -422,10 +259,10 @@ static int ll_loadlib (lua_State *L) {
 */
 
 
-static int readable (const char *filename) {
-  FILE *f = fopen(filename, "r");  /* try to open file */
-  if (f == NULL) return 0;  /* open failed */
-  fclose(f);
+static int readable (nux_ctx_t *ctx, const char *filename) {
+  int slot = nux_io_open(ctx, filename);
+  if (slot == 0) return 0;
+  nux_io_close(ctx, slot);
   return 1;
 }
 
@@ -487,7 +324,7 @@ static const char *searchpath (lua_State *L, const char *name,
   pathname = luaL_buffaddr(&buff);  /* writable list of file names */
   endpathname = pathname + luaL_bufflen(&buff) - 1;
   while ((filename = getnextfilename(&pathname, endpathname)) != NULL) {
-    if (readable(filename))  /* does file exist and is readable? */
+    if (readable(lua_getuserdata(L), filename))  /* does file exist and is readable? */
       return lua_pushstring(L, filename);  /* save and return name */
   }
   luaL_pushresult(&buff);  /* push path to create error message */
@@ -542,61 +379,6 @@ static int searcher_Lua (lua_State *L) {
 }
 
 
-/*
-** Try to find a load function for module 'modname' at file 'filename'.
-** First, change '.' to '_' in 'modname'; then, if 'modname' has
-** the form X-Y (that is, it has an "ignore mark"), build a function
-** name "luaopen_X" and look for it. (For compatibility, if that
-** fails, it also tries "luaopen_Y".) If there is no ignore mark,
-** look for a function named "luaopen_modname".
-*/
-static int loadfunc (lua_State *L, const char *filename, const char *modname) {
-  const char *openfunc;
-  const char *mark;
-  modname = luaL_gsub(L, modname, ".", LUA_OFSEP);
-  mark = strchr(modname, *LUA_IGMARK);
-  if (mark) {
-    int stat;
-    openfunc = lua_pushlstring(L, modname, mark - modname);
-    openfunc = lua_pushfstring(L, LUA_POF"%s", openfunc);
-    stat = lookforfunc(L, filename, openfunc);
-    if (stat != ERRFUNC) return stat;
-    modname = mark + 1;  /* else go ahead and try old-style name */
-  }
-  openfunc = lua_pushfstring(L, LUA_POF"%s", modname);
-  return lookforfunc(L, filename, openfunc);
-}
-
-
-static int searcher_C (lua_State *L) {
-  const char *name = luaL_checkstring(L, 1);
-  const char *filename = findfile(L, name, "cpath", LUA_CSUBSEP);
-  if (filename == NULL) return 1;  /* module not found in this path */
-  return checkload(L, (loadfunc(L, filename, name) == 0), filename);
-}
-
-
-static int searcher_Croot (lua_State *L) {
-  const char *filename;
-  const char *name = luaL_checkstring(L, 1);
-  const char *p = strchr(name, '.');
-  int stat;
-  if (p == NULL) return 0;  /* is root */
-  lua_pushlstring(L, name, p - name);
-  filename = findfile(L, lua_tostring(L, -1), "cpath", LUA_CSUBSEP);
-  if (filename == NULL) return 1;  /* root not found */
-  if ((stat = loadfunc(L, filename, name)) != 0) {
-    if (stat != ERRFUNC)
-      return checkload(L, 0, filename);  /* real error */
-    else {  /* open function not found */
-      lua_pushfstring(L, "no module '%s' in file '%s'", name, filename);
-      return 1;
-    }
-  }
-  lua_pushstring(L, filename);  /* will be 2nd argument to module */
-  return 2;
-}
-
 
 static int searcher_preload (lua_State *L) {
   const char *name = luaL_checkstring(L, 1);
@@ -680,11 +462,9 @@ static int ll_require (lua_State *L) {
 
 
 static const luaL_Reg pk_funcs[] = {
-  {"loadlib", ll_loadlib},
   {"searchpath", ll_searchpath},
   /* placeholders */
   {"preload", NULL},
-  {"cpath", NULL},
   {"path", NULL},
   {"searchers", NULL},
   {"loaded", NULL},
@@ -702,8 +482,6 @@ static void createsearcherstable (lua_State *L) {
   static const lua_CFunction searchers[] = {
     searcher_preload,
     searcher_Lua,
-    searcher_C,
-    searcher_Croot,
     NULL
   };
   int i;
@@ -719,26 +497,11 @@ static void createsearcherstable (lua_State *L) {
 }
 
 
-/*
-** create table CLIBS to keep track of loaded C libraries,
-** setting a finalizer to close all libraries when closing state.
-*/
-static void createclibstable (lua_State *L) {
-  luaL_getsubtable(L, LUA_REGISTRYINDEX, CLIBS);  /* create CLIBS table */
-  lua_createtable(L, 0, 1);  /* create metatable for CLIBS */
-  lua_pushcfunction(L, gctm);
-  lua_setfield(L, -2, "__gc");  /* set finalizer for CLIBS table */
-  lua_setmetatable(L, -2);
-}
-
-
 LUAMOD_API int luaopen_package (lua_State *L) {
-  createclibstable(L);
   luaL_newlib(L, pk_funcs);  /* create 'package' table */
   createsearcherstable(L);
   /* set paths */
-  setpath(L, "path", LUA_PATH_VAR, LUA_PATH_DEFAULT);
-  setpath(L, "cpath", LUA_CPATH_VAR, LUA_CPATH_DEFAULT);
+  setpath(L, "path", LUA_PATH_DEFAULT);
   /* store config information */
   lua_pushliteral(L, LUA_DIRSEP "\n" LUA_PATH_SEP "\n" LUA_PATH_MARK "\n"
                      LUA_EXEC_DIR "\n" LUA_IGMARK "\n");
diff --git a/core/luavm/lstate.c b/core/luavm/lstate.c
index f3f2ccfd..82b7500c 100644
--- a/core/luavm/lstate.c
+++ b/core/luavm/lstate.c
@@ -57,8 +57,6 @@ typedef struct LG {
 */
 #if !defined(luai_makeseed)
 
-#include <time.h>
-
 /*
 ** Compute an initial seed with some level of randomness.
 ** Rely on Address Space Layout Randomization (if present) and
@@ -70,7 +68,7 @@ typedef struct LG {
 
 static unsigned int luai_makeseed (lua_State *L) {
   char buff[3 * sizeof(size_t)];
-  unsigned int h = cast_uint(time(NULL));
+  unsigned int h = cast_uint(nux_random(lua_getuserdata(L)));
   int p = 0;
   addbuff(buff, p, L);  /* heap variable */
   addbuff(buff, p, &h);  /* local variable */
@@ -415,6 +413,10 @@ LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
   return L;
 }
 
+LUA_API void *(lua_getuserdata) (lua_State *L) {
+    return L->l_G->ud;
+}
+
 
 LUA_API void lua_close (lua_State *L) {
   lua_lock(L);
diff --git a/core/luavm/lstate.h b/core/luavm/lstate.h
index 007704c8..3428a1e5 100644
--- a/core/luavm/lstate.h
+++ b/core/luavm/lstate.h
@@ -7,6 +7,7 @@
 #ifndef lstate_h
 #define lstate_h
 
+#include "../internal.h"
 #include "lua.h"
 
 
@@ -329,6 +330,7 @@ struct lua_State {
   int basehookcount;
   int hookcount;
   volatile l_signalT hookmask;
+  nux_ctx_t *ctx;
 };
 
 
diff --git a/core/luavm/ltablib.c b/core/luavm/ltablib.c
index e6bc4d04..c7af73cb 100644
--- a/core/luavm/ltablib.c
+++ b/core/luavm/ltablib.c
@@ -7,6 +7,8 @@
 #define ltablib_c
 #define LUA_LIB
 
+#include "../internal.h"
+
 #include "lprefix.h"
 
 
@@ -232,8 +234,6 @@ typedef unsigned int IdxT;
 */
 #if !defined(l_randomizePivot)		/* { */
 
-#include <time.h>
-
 /* size of 'e' measured in number of 'unsigned int's */
 #define sof(e)		(sizeof(e) / sizeof(unsigned int))
 
@@ -243,16 +243,8 @@ typedef unsigned int IdxT;
 ** anything without risking overflows. A safe way to use their values
 ** is to copy them to an array of a known type and use the array values.
 */
-static unsigned int l_randomizePivot (void) {
-  clock_t c = clock();
-  time_t t = time(NULL);
-  unsigned int buff[sof(c) + sof(t)];
-  unsigned int i, rnd = 0;
-  memcpy(buff, &c, sof(c) * sizeof(unsigned int));
-  memcpy(buff + sof(c), &t, sof(t) * sizeof(unsigned int));
-  for (i = 0; i < sof(buff); i++)
-    rnd += buff[i];
-  return rnd;
+static unsigned int l_randomizePivot (lua_State *L) {
+    return nux_random(lua_getuserdata(L));
 }
 
 #endif					/* } */
@@ -391,7 +383,7 @@ static void auxsort (lua_State *L, IdxT lo, IdxT up,
       up = p - 1;  /* tail call for [lo .. p - 1]  (lower interval) */
     }
     if ((up - lo) / 128 > n) /* partition too imbalanced? */
-      rnd = l_randomizePivot();  /* try a new randomization */
+      rnd = l_randomizePivot(L);  /* try a new randomization */
   }  /* tail call auxsort(L, lo, up, rnd) */
 }
 
diff --git a/core/luavm/lua.h b/core/luavm/lua.h
index f3ea590d..74e81ffc 100644
--- a/core/luavm/lua.h
+++ b/core/luavm/lua.h
@@ -161,6 +161,7 @@ extern const char lua_ident[];
 ** state manipulation
 */
 LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
+LUA_API void      *(lua_getuserdata) (lua_State *L);
 LUA_API void       (lua_close) (lua_State *L);
 LUA_API lua_State *(lua_newthread) (lua_State *L);
 LUA_API int        (lua_closethread) (lua_State *L, lua_State *from);
diff --git a/core/luavm/lua.hpp b/core/luavm/lua.hpp
deleted file mode 100644
index ec417f59..00000000
--- a/core/luavm/lua.hpp
+++ /dev/null
@@ -1,9 +0,0 @@
-// lua.hpp
-// Lua header files for C++
-// <<extern "C">> not supplied automatically because Lua also compiles as C++
-
-extern "C" {
-#include "lua.h"
-#include "lualib.h"
-#include "lauxlib.h"
-}
diff --git a/core/luavm/luac.c b/core/luavm/luac.c
deleted file mode 100644
index 5f4a141b..00000000
--- a/core/luavm/luac.c
+++ /dev/null
@@ -1,723 +0,0 @@
-/*
-** $Id: luac.c $
-** Lua compiler (saves bytecodes to files; also lists bytecodes)
-** See Copyright Notice in lua.h
-*/
-
-#define luac_c
-#define LUA_CORE
-
-#include "lprefix.h"
-
-#include <ctype.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "lua.h"
-#include "lauxlib.h"
-
-#include "ldebug.h"
-#include "lobject.h"
-#include "lopcodes.h"
-#include "lopnames.h"
-#include "lstate.h"
-#include "lundump.h"
-
-static void PrintFunction(const Proto* f, int full);
-#define luaU_print	PrintFunction
-
-#define PROGNAME	"luac"		/* default program name */
-#define OUTPUT		PROGNAME ".out"	/* default output file */
-
-static int listing=0;			/* list bytecodes? */
-static int dumping=1;			/* dump bytecodes? */
-static int stripping=0;			/* strip debug information? */
-static char Output[]={ OUTPUT };	/* default output file name */
-static const char* output=Output;	/* actual output file name */
-static const char* progname=PROGNAME;	/* actual program name */
-static TString **tmname;
-
-static void fatal(const char* message)
-{
- fprintf(stderr,"%s: %s\n",progname,message);
- exit(EXIT_FAILURE);
-}
-
-static void cannot(const char* what)
-{
- fprintf(stderr,"%s: cannot %s %s: %s\n",progname,what,output,strerror(errno));
- exit(EXIT_FAILURE);
-}
-
-static void usage(const char* message)
-{
- if (*message=='-')
-  fprintf(stderr,"%s: unrecognized option '%s'\n",progname,message);
- else
-  fprintf(stderr,"%s: %s\n",progname,message);
- fprintf(stderr,
-  "usage: %s [options] [filenames]\n"
-  "Available options are:\n"
-  "  -l       list (use -l -l for full listing)\n"
-  "  -o name  output to file 'name' (default is \"%s\")\n"
-  "  -p       parse only\n"
-  "  -s       strip debug information\n"
-  "  -v       show version information\n"
-  "  --       stop handling options\n"
-  "  -        stop handling options and process stdin\n"
-  ,progname,Output);
- exit(EXIT_FAILURE);
-}
-
-#define IS(s)	(strcmp(argv[i],s)==0)
-
-static int doargs(int argc, char* argv[])
-{
- int i;
- int version=0;
- if (argv[0]!=NULL && *argv[0]!=0) progname=argv[0];
- for (i=1; i<argc; i++)
- {
-  if (*argv[i]!='-')			/* end of options; keep it */
-   break;
-  else if (IS("--"))			/* end of options; skip it */
-  {
-   ++i;
-   if (version) ++version;
-   break;
-  }
-  else if (IS("-"))			/* end of options; use stdin */
-   break;
-  else if (IS("-l"))			/* list */
-   ++listing;
-  else if (IS("-o"))			/* output file */
-  {
-   output=argv[++i];
-   if (output==NULL || *output==0 || (*output=='-' && output[1]!=0))
-    usage("'-o' needs argument");
-   if (IS("-")) output=NULL;
-  }
-  else if (IS("-p"))			/* parse only */
-   dumping=0;
-  else if (IS("-s"))			/* strip debug information */
-   stripping=1;
-  else if (IS("-v"))			/* show version */
-   ++version;
-  else					/* unknown option */
-   usage(argv[i]);
- }
- if (i==argc && (listing || !dumping))
- {
-  dumping=0;
-  argv[--i]=Output;
- }
- if (version)
- {
-  printf("%s\n",LUA_COPYRIGHT);
-  if (version==argc-1) exit(EXIT_SUCCESS);
- }
- return i;
-}
-
-#define FUNCTION "(function()end)();\n"
-
-static const char* reader(lua_State* L, void* ud, size_t* size)
-{
- UNUSED(L);
- if ((*(int*)ud)--)
- {
-  *size=sizeof(FUNCTION)-1;
-  return FUNCTION;
- }
- else
- {
-  *size=0;
-  return NULL;
- }
-}
-
-#define toproto(L,i) getproto(s2v(L->top.p+(i)))
-
-static const Proto* combine(lua_State* L, int n)
-{
- if (n==1)
-  return toproto(L,-1);
- else
- {
-  Proto* f;
-  int i=n;
-  if (lua_load(L,reader,&i,"=(" PROGNAME ")",NULL)!=LUA_OK) fatal(lua_tostring(L,-1));
-  f=toproto(L,-1);
-  for (i=0; i<n; i++)
-  {
-   f->p[i]=toproto(L,i-n-1);
-   if (f->p[i]->sizeupvalues>0) f->p[i]->upvalues[0].instack=0;
-  }
-  return f;
- }
-}
-
-static int writer(lua_State* L, const void* p, size_t size, void* u)
-{
- UNUSED(L);
- return (fwrite(p,size,1,(FILE*)u)!=1) && (size!=0);
-}
-
-static int pmain(lua_State* L)
-{
- int argc=(int)lua_tointeger(L,1);
- char** argv=(char**)lua_touserdata(L,2);
- const Proto* f;
- int i;
- tmname=G(L)->tmname;
- if (!lua_checkstack(L,argc)) fatal("too many input files");
- for (i=0; i<argc; i++)
- {
-  const char* filename=IS("-") ? NULL : argv[i];
-  if (luaL_loadfile(L,filename)!=LUA_OK) fatal(lua_tostring(L,-1));
- }
- f=combine(L,argc);
- if (listing) luaU_print(f,listing>1);
- if (dumping)
- {
-  FILE* D= (output==NULL) ? stdout : fopen(output,"wb");
-  if (D==NULL) cannot("open");
-  lua_lock(L);
-  luaU_dump(L,f,writer,D,stripping);
-  lua_unlock(L);
-  if (ferror(D)) cannot("write");
-  if (fclose(D)) cannot("close");
- }
- return 0;
-}
-
-int main(int argc, char* argv[])
-{
- lua_State* L;
- int i=doargs(argc,argv);
- argc-=i; argv+=i;
- if (argc<=0) usage("no input files given");
- L=luaL_newstate();
- if (L==NULL) fatal("cannot create state: not enough memory");
- lua_pushcfunction(L,&pmain);
- lua_pushinteger(L,argc);
- lua_pushlightuserdata(L,argv);
- if (lua_pcall(L,2,0,0)!=LUA_OK) fatal(lua_tostring(L,-1));
- lua_close(L);
- return EXIT_SUCCESS;
-}
-
-/*
-** print bytecodes
-*/
-
-#define UPVALNAME(x) ((f->upvalues[x].name) ? getstr(f->upvalues[x].name) : "-")
-#define VOID(p) ((const void*)(p))
-#define eventname(i) (getstr(tmname[i]))
-
-static void PrintString(const TString* ts)
-{
- const char* s=getstr(ts);
- size_t i,n=tsslen(ts);
- printf("\"");
- for (i=0; i<n; i++)
- {
-  int c=(int)(unsigned char)s[i];
-  switch (c)
-  {
-   case '"':
-	printf("\\\"");
-	break;
-   case '\\':
-	printf("\\\\");
-	break;
-   case '\a':
-	printf("\\a");
-	break;
-   case '\b':
-	printf("\\b");
-	break;
-   case '\f':
-	printf("\\f");
-	break;
-   case '\n':
-	printf("\\n");
-	break;
-   case '\r':
-	printf("\\r");
-	break;
-   case '\t':
-	printf("\\t");
-	break;
-   case '\v':
-	printf("\\v");
-	break;
-   default:
-	if (isprint(c)) printf("%c",c); else printf("\\%03d",c);
-	break;
-  }
- }
- printf("\"");
-}
-
-static void PrintType(const Proto* f, int i)
-{
- const TValue* o=&f->k[i];
- switch (ttypetag(o))
- {
-  case LUA_VNIL:
-	printf("N");
-	break;
-  case LUA_VFALSE:
-  case LUA_VTRUE:
-	printf("B");
-	break;
-  case LUA_VNUMFLT:
-	printf("F");
-	break;
-  case LUA_VNUMINT:
-	printf("I");
-	break;
-  case LUA_VSHRSTR:
-  case LUA_VLNGSTR:
-	printf("S");
-	break;
-  default:				/* cannot happen */
-	printf("?%d",ttypetag(o));
-	break;
- }
- printf("\t");
-}
-
-static void PrintConstant(const Proto* f, int i)
-{
- const TValue* o=&f->k[i];
- switch (ttypetag(o))
- {
-  case LUA_VNIL:
-	printf("nil");
-	break;
-  case LUA_VFALSE:
-	printf("false");
-	break;
-  case LUA_VTRUE:
-	printf("true");
-	break;
-  case LUA_VNUMFLT:
-	{
-	char buff[100];
-	sprintf(buff,LUA_NUMBER_FMT,fltvalue(o));
-	printf("%s",buff);
-	if (buff[strspn(buff,"-0123456789")]=='\0') printf(".0");
-	break;
-	}
-  case LUA_VNUMINT:
-	printf(LUA_INTEGER_FMT,ivalue(o));
-	break;
-  case LUA_VSHRSTR:
-  case LUA_VLNGSTR:
-	PrintString(tsvalue(o));
-	break;
-  default:				/* cannot happen */
-	printf("?%d",ttypetag(o));
-	break;
- }
-}
-
-#define COMMENT		"\t; "
-#define EXTRAARG	GETARG_Ax(code[pc+1])
-#define EXTRAARGC	(EXTRAARG*(MAXARG_C+1))
-#define ISK		(isk ? "k" : "")
-
-static void PrintCode(const Proto* f)
-{
- const Instruction* code=f->code;
- int pc,n=f->sizecode;
- for (pc=0; pc<n; pc++)
- {
-  Instruction i=code[pc];
-  OpCode o=GET_OPCODE(i);
-  int a=GETARG_A(i);
-  int b=GETARG_B(i);
-  int c=GETARG_C(i);
-  int ax=GETARG_Ax(i);
-  int bx=GETARG_Bx(i);
-  int sb=GETARG_sB(i);
-  int sc=GETARG_sC(i);
-  int sbx=GETARG_sBx(i);
-  int isk=GETARG_k(i);
-  int line=luaG_getfuncline(f,pc);
-  printf("\t%d\t",pc+1);
-  if (line>0) printf("[%d]\t",line); else printf("[-]\t");
-  printf("%-9s\t",opnames[o]);
-  switch (o)
-  {
-   case OP_MOVE:
-	printf("%d %d",a,b);
-	break;
-   case OP_LOADI:
-	printf("%d %d",a,sbx);
-	break;
-   case OP_LOADF:
-	printf("%d %d",a,sbx);
-	break;
-   case OP_LOADK:
-	printf("%d %d",a,bx);
-	printf(COMMENT); PrintConstant(f,bx);
-	break;
-   case OP_LOADKX:
-	printf("%d",a);
-	printf(COMMENT); PrintConstant(f,EXTRAARG);
-	break;
-   case OP_LOADFALSE:
-	printf("%d",a);
-	break;
-   case OP_LFALSESKIP:
-	printf("%d",a);
-	break;
-   case OP_LOADTRUE:
-	printf("%d",a);
-	break;
-   case OP_LOADNIL:
-	printf("%d %d",a,b);
-	printf(COMMENT "%d out",b+1);
-	break;
-   case OP_GETUPVAL:
-	printf("%d %d",a,b);
-	printf(COMMENT "%s",UPVALNAME(b));
-	break;
-   case OP_SETUPVAL:
-	printf("%d %d",a,b);
-	printf(COMMENT "%s",UPVALNAME(b));
-	break;
-   case OP_GETTABUP:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT "%s",UPVALNAME(b));
-	printf(" "); PrintConstant(f,c);
-	break;
-   case OP_GETTABLE:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_GETI:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_GETFIELD:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT); PrintConstant(f,c);
-	break;
-   case OP_SETTABUP:
-	printf("%d %d %d%s",a,b,c,ISK);
-	printf(COMMENT "%s",UPVALNAME(a));
-	printf(" "); PrintConstant(f,b);
-	if (isk) { printf(" "); PrintConstant(f,c); }
-	break;
-   case OP_SETTABLE:
-	printf("%d %d %d%s",a,b,c,ISK);
-	if (isk) { printf(COMMENT); PrintConstant(f,c); }
-	break;
-   case OP_SETI:
-	printf("%d %d %d%s",a,b,c,ISK);
-	if (isk) { printf(COMMENT); PrintConstant(f,c); }
-	break;
-   case OP_SETFIELD:
-	printf("%d %d %d%s",a,b,c,ISK);
-	printf(COMMENT); PrintConstant(f,b);
-	if (isk) { printf(" "); PrintConstant(f,c); }
-	break;
-   case OP_NEWTABLE:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT "%d",c+EXTRAARGC);
-	break;
-   case OP_SELF:
-	printf("%d %d %d%s",a,b,c,ISK);
-	if (isk) { printf(COMMENT); PrintConstant(f,c); }
-	break;
-   case OP_ADDI:
-	printf("%d %d %d",a,b,sc);
-	break;
-   case OP_ADDK:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT); PrintConstant(f,c);
-	break;
-   case OP_SUBK:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT); PrintConstant(f,c);
-	break;
-   case OP_MULK:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT); PrintConstant(f,c);
-	break;
-   case OP_MODK:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT); PrintConstant(f,c);
-	break;
-   case OP_POWK:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT); PrintConstant(f,c);
-	break;
-   case OP_DIVK:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT); PrintConstant(f,c);
-	break;
-   case OP_IDIVK:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT); PrintConstant(f,c);
-	break;
-   case OP_BANDK:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT); PrintConstant(f,c);
-	break;
-   case OP_BORK:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT); PrintConstant(f,c);
-	break;
-   case OP_BXORK:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT); PrintConstant(f,c);
-	break;
-   case OP_SHRI:
-	printf("%d %d %d",a,b,sc);
-	break;
-   case OP_SHLI:
-	printf("%d %d %d",a,b,sc);
-	break;
-   case OP_ADD:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_SUB:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_MUL:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_MOD:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_POW:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_DIV:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_IDIV:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_BAND:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_BOR:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_BXOR:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_SHL:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_SHR:
-	printf("%d %d %d",a,b,c);
-	break;
-   case OP_MMBIN:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT "%s",eventname(c));
-	break;
-   case OP_MMBINI:
-	printf("%d %d %d %d",a,sb,c,isk);
-	printf(COMMENT "%s",eventname(c));
-	if (isk) printf(" flip");
-	break;
-   case OP_MMBINK:
-	printf("%d %d %d %d",a,b,c,isk);
-	printf(COMMENT "%s ",eventname(c)); PrintConstant(f,b);
-	if (isk) printf(" flip");
-	break;
-   case OP_UNM:
-	printf("%d %d",a,b);
-	break;
-   case OP_BNOT:
-	printf("%d %d",a,b);
-	break;
-   case OP_NOT:
-	printf("%d %d",a,b);
-	break;
-   case OP_LEN:
-	printf("%d %d",a,b);
-	break;
-   case OP_CONCAT:
-	printf("%d %d",a,b);
-	break;
-   case OP_CLOSE:
-	printf("%d",a);
-	break;
-   case OP_TBC:
-	printf("%d",a);
-	break;
-   case OP_JMP:
-	printf("%d",GETARG_sJ(i));
-	printf(COMMENT "to %d",GETARG_sJ(i)+pc+2);
-	break;
-   case OP_EQ:
-	printf("%d %d %d",a,b,isk);
-	break;
-   case OP_LT:
-	printf("%d %d %d",a,b,isk);
-	break;
-   case OP_LE:
-	printf("%d %d %d",a,b,isk);
-	break;
-   case OP_EQK:
-	printf("%d %d %d",a,b,isk);
-	printf(COMMENT); PrintConstant(f,b);
-	break;
-   case OP_EQI:
-	printf("%d %d %d",a,sb,isk);
-	break;
-   case OP_LTI:
-	printf("%d %d %d",a,sb,isk);
-	break;
-   case OP_LEI:
-	printf("%d %d %d",a,sb,isk);
-	break;
-   case OP_GTI:
-	printf("%d %d %d",a,sb,isk);
-	break;
-   case OP_GEI:
-	printf("%d %d %d",a,sb,isk);
-	break;
-   case OP_TEST:
-	printf("%d %d",a,isk);
-	break;
-   case OP_TESTSET:
-	printf("%d %d %d",a,b,isk);
-	break;
-   case OP_CALL:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT);
-	if (b==0) printf("all in "); else printf("%d in ",b-1);
-	if (c==0) printf("all out"); else printf("%d out",c-1);
-	break;
-   case OP_TAILCALL:
-	printf("%d %d %d%s",a,b,c,ISK);
-	printf(COMMENT "%d in",b-1);
-	break;
-   case OP_RETURN:
-	printf("%d %d %d%s",a,b,c,ISK);
-	printf(COMMENT);
-	if (b==0) printf("all out"); else printf("%d out",b-1);
-	break;
-   case OP_RETURN0:
-	break;
-   case OP_RETURN1:
-	printf("%d",a);
-	break;
-   case OP_FORLOOP:
-	printf("%d %d",a,bx);
-	printf(COMMENT "to %d",pc-bx+2);
-	break;
-   case OP_FORPREP:
-	printf("%d %d",a,bx);
-	printf(COMMENT "exit to %d",pc+bx+3);
-	break;
-   case OP_TFORPREP:
-	printf("%d %d",a,bx);
-	printf(COMMENT "to %d",pc+bx+2);
-	break;
-   case OP_TFORCALL:
-	printf("%d %d",a,c);
-	break;
-   case OP_TFORLOOP:
-	printf("%d %d",a,bx);
-	printf(COMMENT "to %d",pc-bx+2);
-	break;
-   case OP_SETLIST:
-	printf("%d %d %d",a,b,c);
-	if (isk) printf(COMMENT "%d",c+EXTRAARGC);
-	break;
-   case OP_CLOSURE:
-	printf("%d %d",a,bx);
-	printf(COMMENT "%p",VOID(f->p[bx]));
-	break;
-   case OP_VARARG:
-	printf("%d %d",a,c);
-	printf(COMMENT);
-	if (c==0) printf("all out"); else printf("%d out",c-1);
-	break;
-   case OP_VARARGPREP:
-	printf("%d",a);
-	break;
-   case OP_EXTRAARG:
-	printf("%d",ax);
-	break;
-#if 0
-   default:
-	printf("%d %d %d",a,b,c);
-	printf(COMMENT "not handled");
-	break;
-#endif
-  }
-  printf("\n");
- }
-}
-
-
-#define SS(x)	((x==1)?"":"s")
-#define S(x)	(int)(x),SS(x)
-
-static void PrintHeader(const Proto* f)
-{
- const char* s=f->source ? getstr(f->source) : "=?";
- if (*s=='@' || *s=='=')
-  s++;
- else if (*s==LUA_SIGNATURE[0])
-  s="(bstring)";
- else
-  s="(string)";
- printf("\n%s <%s:%d,%d> (%d instruction%s at %p)\n",
-	(f->linedefined==0)?"main":"function",s,
-	f->linedefined,f->lastlinedefined,
-	S(f->sizecode),VOID(f));
- printf("%d%s param%s, %d slot%s, %d upvalue%s, ",
-	(int)(f->numparams),f->is_vararg?"+":"",SS(f->numparams),
-	S(f->maxstacksize),S(f->sizeupvalues));
- printf("%d local%s, %d constant%s, %d function%s\n",
-	S(f->sizelocvars),S(f->sizek),S(f->sizep));
-}
-
-static void PrintDebug(const Proto* f)
-{
- int i,n;
- n=f->sizek;
- printf("constants (%d) for %p:\n",n,VOID(f));
- for (i=0; i<n; i++)
- {
-  printf("\t%d\t",i);
-  PrintType(f,i);
-  PrintConstant(f,i);
-  printf("\n");
- }
- n=f->sizelocvars;
- printf("locals (%d) for %p:\n",n,VOID(f));
- for (i=0; i<n; i++)
- {
-  printf("\t%d\t%s\t%d\t%d\n",
-  i,getstr(f->locvars[i].varname),f->locvars[i].startpc+1,f->locvars[i].endpc+1);
- }
- n=f->sizeupvalues;
- printf("upvalues (%d) for %p:\n",n,VOID(f));
- for (i=0; i<n; i++)
- {
-  printf("\t%d\t%s\t%d\t%d\n",
-  i,UPVALNAME(i),f->upvalues[i].instack,f->upvalues[i].idx);
- }
-}
-
-static void PrintFunction(const Proto* f, int full)
-{
- int i,n=f->sizep;
- PrintHeader(f);
- PrintCode(f);
- if (full) PrintDebug(f);
- for (i=0; i<n; i++) PrintFunction(f->p[i],full);
-}
diff --git a/core/luavm/luaconf.h b/core/luavm/luaconf.h
index 33bb580d..e4d6966c 100644
--- a/core/luavm/luaconf.h
+++ b/core/luavm/luaconf.h
@@ -48,7 +48,7 @@
 ** By default, Lua on Windows use (some) specific Windows features
 */
 #if !defined(LUA_USE_C89) && defined(_WIN32) && !defined(_WIN32_WCE)
-#define LUA_USE_WINDOWS  /* enable goodies for regular Windows */
+// #define LUA_USE_WINDOWS  /* enable goodies for regular Windows */
 #endif
 
 
@@ -59,20 +59,20 @@
 
 
 #if defined(LUA_USE_LINUX)
-#define LUA_USE_POSIX
-#define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
+// #define LUA_USE_POSIX
+// #define LUA_USE_DLOPEN		/* needs an extra library: -ldl */
 #endif
 
 
 #if defined(LUA_USE_MACOSX)
-#define LUA_USE_POSIX
-#define LUA_USE_DLOPEN		/* MacOS does not need -ldl */
+// #define LUA_USE_POSIX
+// #define LUA_USE_DLOPEN		/* MacOS does not need -ldl */
 #endif
 
 
 #if defined(LUA_USE_IOS)
-#define LUA_USE_POSIX
-#define LUA_USE_DLOPEN
+// #define LUA_USE_POSIX
+// #define LUA_USE_DLOPEN
 #endif
 
 
@@ -197,66 +197,15 @@
 */
 
 #define LUA_VDIR	LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
-#if defined(_WIN32)	/* { */
-/*
-** In Windows, any exclamation mark ('!') in the path is replaced by the
-** path of the directory of the executable file of the current process.
-*/
-#define LUA_LDIR	"!\\lua\\"
-#define LUA_CDIR	"!\\"
-#define LUA_SHRDIR	"!\\..\\share\\lua\\" LUA_VDIR "\\"
-
-#if !defined(LUA_PATH_DEFAULT)
-#define LUA_PATH_DEFAULT  \
-		LUA_LDIR"?.lua;"  LUA_LDIR"?\\init.lua;" \
-		LUA_CDIR"?.lua;"  LUA_CDIR"?\\init.lua;" \
-		LUA_SHRDIR"?.lua;" LUA_SHRDIR"?\\init.lua;" \
-		".\\?.lua;" ".\\?\\init.lua"
-#endif
-
-#if !defined(LUA_CPATH_DEFAULT)
-#define LUA_CPATH_DEFAULT \
-		LUA_CDIR"?.dll;" \
-		LUA_CDIR"..\\lib\\lua\\" LUA_VDIR "\\?.dll;" \
-		LUA_CDIR"loadall.dll;" ".\\?.dll"
-#endif
-
-#else			/* }{ */
-
-#define LUA_ROOT	"/usr/local/"
-#define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR "/"
-#define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR "/"
-
-#if !defined(LUA_PATH_DEFAULT)
-#define LUA_PATH_DEFAULT  \
-		LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
-		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" \
-		"./?.lua;" "./?/init.lua"
-#endif
-
-#if !defined(LUA_CPATH_DEFAULT)
-#define LUA_CPATH_DEFAULT \
-		LUA_CDIR"?.so;" LUA_CDIR"loadall.so;" "./?.so"
-#endif
-
-#endif			/* } */
 
+#define LUA_PATH_DEFAULT "?.lua;?/init.lua"
 
 /*
 @@ LUA_DIRSEP is the directory separator (for submodules).
 ** CHANGE it if your machine does not use "/" as the directory separator
 ** and is not Windows. (On Windows Lua automatically uses "\".)
 */
-#if !defined(LUA_DIRSEP)
-
-#if defined(_WIN32)
-#define LUA_DIRSEP	"\\"
-#else
 #define LUA_DIRSEP	"/"
-#endif
-
-#endif
-
 
 /*
 ** LUA_IGMARK is a mark to ignore all after it when building the
