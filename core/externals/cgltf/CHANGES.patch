929d928
< #include <stdio.h>  /* For fopen */
937,983d935
< /* JSMN_PARENT_LINKS is necessary to make parsing large structures linear in input size */
< #define JSMN_PARENT_LINKS
< 
< /* JSMN_STRICT is necessary to reject invalid JSON documents */
< #define JSMN_STRICT
< 
< /*
<  * -- jsmn.h start --
<  * Source: https://github.com/zserge/jsmn
<  * License: MIT
<  */
< typedef enum {
< 	JSMN_UNDEFINED = 0,
< 	JSMN_OBJECT = 1,
< 	JSMN_ARRAY = 2,
< 	JSMN_STRING = 3,
< 	JSMN_PRIMITIVE = 4
< } jsmntype_t;
< enum jsmnerr {
< 	/* Not enough tokens were provided */
< 	JSMN_ERROR_NOMEM = -1,
< 	/* Invalid character inside JSON string */
< 	JSMN_ERROR_INVAL = -2,
< 	/* The string is not a full JSON packet, more bytes expected */
< 	JSMN_ERROR_PART = -3
< };
< typedef struct {
< 	jsmntype_t type;
< 	ptrdiff_t start;
< 	ptrdiff_t end;
< 	int size;
< #ifdef JSMN_PARENT_LINKS
< 	int parent;
< #endif
< } jsmntok_t;
< typedef struct {
< 	size_t pos; /* offset in the JSON string */
< 	unsigned int toknext; /* next token to allocate */
< 	int toksuper; /* superior token node, e.g parent object or array */
< } jsmn_parser;
< static void jsmn_init(jsmn_parser *parser);
< static int jsmn_parse(jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, size_t num_tokens);
< /*
<  * -- jsmn.h end --
<  */
< 
< 
1040,1102d991
< static cgltf_result cgltf_default_file_read(const struct cgltf_memory_options* memory_options, const struct cgltf_file_options* file_options, const char* path, cgltf_size* size, void** data)
< {
< 	(void)file_options;
< 	void* (*memory_alloc)(void*, cgltf_size) = memory_options->alloc_func ? memory_options->alloc_func : &cgltf_default_alloc;
< 	void (*memory_free)(void*, void*) = memory_options->free_func ? memory_options->free_func : &cgltf_default_free;
< 
< 	FILE* file = fopen(path, "rb");
< 	if (!file)
< 	{
< 		return cgltf_result_file_not_found;
< 	}
< 
< 	cgltf_size file_size = size ? *size : 0;
< 
< 	if (file_size == 0)
< 	{
< 		fseek(file, 0, SEEK_END);
< 
< #ifdef _MSC_VER
< 		__int64 length = _ftelli64(file);
< #else
< 		long length = ftell(file);
< #endif
< 
< 		if (length < 0)
< 		{
< 			fclose(file);
< 			return cgltf_result_io_error;
< 		}
< 
< 		fseek(file, 0, SEEK_SET);
< 		file_size = (cgltf_size)length;
< 	}
< 
< 	char* file_data = (char*)memory_alloc(memory_options->user_data, file_size);
< 	if (!file_data)
< 	{
< 		fclose(file);
< 		return cgltf_result_out_of_memory;
< 	}
< 
< 	cgltf_size read_size = fread(file_data, 1, file_size, file);
< 
< 	fclose(file);
< 
< 	if (read_size != file_size)
< 	{
< 		memory_free(memory_options->user_data, file_data);
< 		return cgltf_result_io_error;
< 	}
< 
< 	if (size)
< 	{
< 		*size = file_size;
< 	}
< 	if (data)
< 	{
< 		*data = file_data;
< 	}
< 
< 	return cgltf_result_success;
< }
< 
1245,1276d1133
< cgltf_result cgltf_parse_file(const cgltf_options* options, const char* path, cgltf_data** out_data)
< {
< 	if (options == NULL)
< 	{
< 		return cgltf_result_invalid_options;
< 	}
< 
< 	cgltf_result (*file_read)(const struct cgltf_memory_options*, const struct cgltf_file_options*, const char*, cgltf_size*, void**) = options->file.read ? options->file.read : &cgltf_default_file_read;
< 	void (*file_release)(const struct cgltf_memory_options*, const struct cgltf_file_options*, void* data, cgltf_size size) = options->file.release ? options->file.release : cgltf_default_file_release;
< 
< 	void* file_data = NULL;
< 	cgltf_size file_size = 0;
< 	cgltf_result result = file_read(&options->memory, &options->file, path, &file_size, &file_data);
< 	if (result != cgltf_result_success)
< 	{
< 		return result;
< 	}
< 
< 	result = cgltf_parse(options, file_data, file_size, out_data);
< 
< 	if (result != cgltf_result_success)
< 	{
< 		file_release(&options->memory, &options->file, file_data, file_size);
< 		return result;
< 	}
< 
< 	(*out_data)->file_data = file_data;
< 	(*out_data)->file_size = file_size;
< 
< 	return cgltf_result_success;
< }
< 
1296,1322d1152
< static cgltf_result cgltf_load_buffer_file(const cgltf_options* options, cgltf_size size, const char* uri, const char* gltf_path, void** out_data)
< {
< 	void* (*memory_alloc)(void*, cgltf_size) = options->memory.alloc_func ? options->memory.alloc_func : &cgltf_default_alloc;
< 	void (*memory_free)(void*, void*) = options->memory.free_func ? options->memory.free_func : &cgltf_default_free;
< 	cgltf_result (*file_read)(const struct cgltf_memory_options*, const struct cgltf_file_options*, const char*, cgltf_size*, void**) = options->file.read ? options->file.read : &cgltf_default_file_read;
< 
< 	char* path = (char*)memory_alloc(options->memory.user_data, strlen(uri) + strlen(gltf_path) + 1);
< 	if (!path)
< 	{
< 		return cgltf_result_out_of_memory;
< 	}
< 
< 	cgltf_combine_paths(path, gltf_path, uri);
< 
< 	// after combining, the tail of the resulting path is a uri; decode_uri converts it into path
< 	cgltf_decode_uri(path + strlen(path) - strlen(uri));
< 
< 	void* file_data = NULL;
< 	cgltf_result result = file_read(&options->memory, &options->file, path, &size, &file_data);
< 
< 	memory_free(options->memory.user_data, path);
< 
< 	*out_data = (result == cgltf_result_success) ? file_data : NULL;
< 
< 	return result;
< }
< 
1532,1541d1361
< 		else if (strstr(uri, "://") == NULL && gltf_path)
< 		{
< 			cgltf_result res = cgltf_load_buffer_file(options, data->buffers[i].size, uri, gltf_path, &data->buffers[i].data);
< 			data->buffers[i].data_free_method = cgltf_data_free_method_file_release;
< 
< 			if (res != cgltf_result_success)
< 			{
< 				return res;
< 			}
< 		}
6863,7203d6682
< 
< /*
<  * -- jsmn.c start --
<  * Source: https://github.com/zserge/jsmn
<  * License: MIT
<  *
<  * Copyright (c) 2010 Serge A. Zaitsev
< 
<  * Permission is hereby granted, free of charge, to any person obtaining a copy
<  * of this software and associated documentation files (the "Software"), to deal
<  * in the Software without restriction, including without limitation the rights
<  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
<  * copies of the Software, and to permit persons to whom the Software is
<  * furnished to do so, subject to the following conditions:
< 
<  * The above copyright notice and this permission notice shall be included in
<  * all copies or substantial portions of the Software.
< 
<  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
<  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
<  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
<  * THE SOFTWARE.
<  */
< 
< /**
<  * Allocates a fresh unused token from the token pull.
<  */
< static jsmntok_t *jsmn_alloc_token(jsmn_parser *parser,
< 				   jsmntok_t *tokens, size_t num_tokens) {
< 	jsmntok_t *tok;
< 	if (parser->toknext >= num_tokens) {
< 		return NULL;
< 	}
< 	tok = &tokens[parser->toknext++];
< 	tok->start = tok->end = -1;
< 	tok->size = 0;
< #ifdef JSMN_PARENT_LINKS
< 	tok->parent = -1;
< #endif
< 	return tok;
< }
< 
< /**
<  * Fills token type and boundaries.
<  */
< static void jsmn_fill_token(jsmntok_t *token, jsmntype_t type,
< 				ptrdiff_t start, ptrdiff_t end) {
< 	token->type = type;
< 	token->start = start;
< 	token->end = end;
< 	token->size = 0;
< }
< 
< /**
<  * Fills next available token with JSON primitive.
<  */
< static int jsmn_parse_primitive(jsmn_parser *parser, const char *js,
< 				size_t len, jsmntok_t *tokens, size_t num_tokens) {
< 	jsmntok_t *token;
< 	ptrdiff_t start;
< 
< 	start = parser->pos;
< 
< 	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
< 		switch (js[parser->pos]) {
< #ifndef JSMN_STRICT
< 		/* In strict mode primitive must be followed by "," or "}" or "]" */
< 		case ':':
< #endif
< 		case '\t' : case '\r' : case '\n' : case ' ' :
< 		case ','  : case ']'  : case '}' :
< 			goto found;
< 		}
< 		if (js[parser->pos] < 32 || js[parser->pos] >= 127) {
< 			parser->pos = start;
< 			return JSMN_ERROR_INVAL;
< 		}
< 	}
< #ifdef JSMN_STRICT
< 	/* In strict mode primitive must be followed by a comma/object/array */
< 	parser->pos = start;
< 	return JSMN_ERROR_PART;
< #endif
< 
< found:
< 	if (tokens == NULL) {
< 		parser->pos--;
< 		return 0;
< 	}
< 	token = jsmn_alloc_token(parser, tokens, num_tokens);
< 	if (token == NULL) {
< 		parser->pos = start;
< 		return JSMN_ERROR_NOMEM;
< 	}
< 	jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);
< #ifdef JSMN_PARENT_LINKS
< 	token->parent = parser->toksuper;
< #endif
< 	parser->pos--;
< 	return 0;
< }
< 
< /**
<  * Fills next token with JSON string.
<  */
< static int jsmn_parse_string(jsmn_parser *parser, const char *js,
< 				 size_t len, jsmntok_t *tokens, size_t num_tokens) {
< 	jsmntok_t *token;
< 
< 	ptrdiff_t start = parser->pos;
< 
< 	parser->pos++;
< 
< 	/* Skip starting quote */
< 	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
< 		char c = js[parser->pos];
< 
< 		/* Quote: end of string */
< 		if (c == '\"') {
< 			if (tokens == NULL) {
< 				return 0;
< 			}
< 			token = jsmn_alloc_token(parser, tokens, num_tokens);
< 			if (token == NULL) {
< 				parser->pos = start;
< 				return JSMN_ERROR_NOMEM;
< 			}
< 			jsmn_fill_token(token, JSMN_STRING, start+1, parser->pos);
< #ifdef JSMN_PARENT_LINKS
< 			token->parent = parser->toksuper;
< #endif
< 			return 0;
< 		}
< 
< 		/* Backslash: Quoted symbol expected */
< 		if (c == '\\' && parser->pos + 1 < len) {
< 			int i;
< 			parser->pos++;
< 			switch (js[parser->pos]) {
< 			/* Allowed escaped symbols */
< 			case '\"': case '/' : case '\\' : case 'b' :
< 			case 'f' : case 'r' : case 'n'  : case 't' :
< 				break;
< 				/* Allows escaped symbol \uXXXX */
< 			case 'u':
< 				parser->pos++;
< 				for(i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\0'; i++) {
< 					/* If it isn't a hex character we have an error */
< 					if(!((js[parser->pos] >= 48 && js[parser->pos] <= 57) || /* 0-9 */
< 						 (js[parser->pos] >= 65 && js[parser->pos] <= 70) || /* A-F */
< 						 (js[parser->pos] >= 97 && js[parser->pos] <= 102))) { /* a-f */
< 						parser->pos = start;
< 						return JSMN_ERROR_INVAL;
< 					}
< 					parser->pos++;
< 				}
< 				parser->pos--;
< 				break;
< 				/* Unexpected symbol */
< 			default:
< 				parser->pos = start;
< 				return JSMN_ERROR_INVAL;
< 			}
< 		}
< 	}
< 	parser->pos = start;
< 	return JSMN_ERROR_PART;
< }
< 
< /**
<  * Parse JSON string and fill tokens.
<  */
< static int jsmn_parse(jsmn_parser *parser, const char *js, size_t len,
< 		   jsmntok_t *tokens, size_t num_tokens) {
< 	int r;
< 	int i;
< 	jsmntok_t *token;
< 	int count = parser->toknext;
< 
< 	for (; parser->pos < len && js[parser->pos] != '\0'; parser->pos++) {
< 		char c;
< 		jsmntype_t type;
< 
< 		c = js[parser->pos];
< 		switch (c) {
< 		case '{': case '[':
< 			count++;
< 			if (tokens == NULL) {
< 				break;
< 			}
< 			token = jsmn_alloc_token(parser, tokens, num_tokens);
< 			if (token == NULL)
< 				return JSMN_ERROR_NOMEM;
< 			if (parser->toksuper != -1) {
< 				tokens[parser->toksuper].size++;
< #ifdef JSMN_PARENT_LINKS
< 				token->parent = parser->toksuper;
< #endif
< 			}
< 			token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
< 			token->start = parser->pos;
< 			parser->toksuper = parser->toknext - 1;
< 			break;
< 		case '}': case ']':
< 			if (tokens == NULL)
< 				break;
< 			type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
< #ifdef JSMN_PARENT_LINKS
< 			if (parser->toknext < 1) {
< 				return JSMN_ERROR_INVAL;
< 			}
< 			token = &tokens[parser->toknext - 1];
< 			for (;;) {
< 				if (token->start != -1 && token->end == -1) {
< 					if (token->type != type) {
< 						return JSMN_ERROR_INVAL;
< 					}
< 					token->end = parser->pos + 1;
< 					parser->toksuper = token->parent;
< 					break;
< 				}
< 				if (token->parent == -1) {
< 					if(token->type != type || parser->toksuper == -1) {
< 						return JSMN_ERROR_INVAL;
< 					}
< 					break;
< 				}
< 				token = &tokens[token->parent];
< 			}
< #else
< 			for (i = parser->toknext - 1; i >= 0; i--) {
< 				token = &tokens[i];
< 				if (token->start != -1 && token->end == -1) {
< 					if (token->type != type) {
< 						return JSMN_ERROR_INVAL;
< 					}
< 					parser->toksuper = -1;
< 					token->end = parser->pos + 1;
< 					break;
< 				}
< 			}
< 			/* Error if unmatched closing bracket */
< 			if (i == -1) return JSMN_ERROR_INVAL;
< 			for (; i >= 0; i--) {
< 				token = &tokens[i];
< 				if (token->start != -1 && token->end == -1) {
< 					parser->toksuper = i;
< 					break;
< 				}
< 			}
< #endif
< 			break;
< 		case '\"':
< 			r = jsmn_parse_string(parser, js, len, tokens, num_tokens);
< 			if (r < 0) return r;
< 			count++;
< 			if (parser->toksuper != -1 && tokens != NULL)
< 				tokens[parser->toksuper].size++;
< 			break;
< 		case '\t' : case '\r' : case '\n' : case ' ':
< 			break;
< 		case ':':
< 			parser->toksuper = parser->toknext - 1;
< 			break;
< 		case ',':
< 			if (tokens != NULL && parser->toksuper != -1 &&
< 					tokens[parser->toksuper].type != JSMN_ARRAY &&
< 					tokens[parser->toksuper].type != JSMN_OBJECT) {
< #ifdef JSMN_PARENT_LINKS
< 				parser->toksuper = tokens[parser->toksuper].parent;
< #else
< 				for (i = parser->toknext - 1; i >= 0; i--) {
< 					if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) {
< 						if (tokens[i].start != -1 && tokens[i].end == -1) {
< 							parser->toksuper = i;
< 							break;
< 						}
< 					}
< 				}
< #endif
< 			}
< 			break;
< #ifdef JSMN_STRICT
< 			/* In strict mode primitives are: numbers and booleans */
< 		case '-': case '0': case '1' : case '2': case '3' : case '4':
< 		case '5': case '6': case '7' : case '8': case '9':
< 		case 't': case 'f': case 'n' :
< 			/* And they must not be keys of the object */
< 			if (tokens != NULL && parser->toksuper != -1) {
< 				jsmntok_t *t = &tokens[parser->toksuper];
< 				if (t->type == JSMN_OBJECT ||
< 						(t->type == JSMN_STRING && t->size != 0)) {
< 					return JSMN_ERROR_INVAL;
< 				}
< 			}
< #else
< 			/* In non-strict mode every unquoted value is a primitive */
< 		default:
< #endif
< 			r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);
< 			if (r < 0) return r;
< 			count++;
< 			if (parser->toksuper != -1 && tokens != NULL)
< 				tokens[parser->toksuper].size++;
< 			break;
< 
< #ifdef JSMN_STRICT
< 			/* Unexpected char in strict mode */
< 		default:
< 			return JSMN_ERROR_INVAL;
< #endif
< 		}
< 	}
< 
< 	if (tokens != NULL) {
< 		for (i = parser->toknext - 1; i >= 0; i--) {
< 			/* Unmatched opened object or array */
< 			if (tokens[i].start != -1 && tokens[i].end == -1) {
< 				return JSMN_ERROR_PART;
< 			}
< 		}
< 	}
< 
< 	return count;
< }
< 
< /**
<  * Creates a new parser based over a given  buffer with an array of tokens
<  * available.
<  */
< static void jsmn_init(jsmn_parser *parser) {
< 	parser->pos = 0;
< 	parser->toknext = 0;
< 	parser->toksuper = -1;
< }
< /*
<  * -- jsmn.c end --
<  */
