#include <nulib/nulib.h>
static const nu_sv_t shader_canvas_blit_frag = NU_SV(
"#version 330\n"
"\n"
"in vec2 uv;\n"
"out vec4 color;\n"
"\n"
"uniform sampler2D texture0;\n"
"\n"
"void main()\n"
"{\n"
"    color = texture(texture0, uv);\n"
"}\n"
);
static const nu_sv_t shader_canvas_blit_vert = NU_SV(
"#version 330\n"
"\n"
"layout(location = 0) in uint pos;\n"
"layout(location = 1) in uint tex;\n"
"layout(location = 2) in uint size;\n"
"\n"
"uniform sampler2D texture0;\n"
"uniform uvec2 viewport_size;\n"
"\n"
"out vec2 uv;\n"
"\n"
"const vec2 offsets[6] = vec2[](\n"
"    vec2(0, 0),\n"
"    vec2(0, 1),\n"
"    vec2(1, 1),\n"
"    vec2(1, 1),\n"
"    vec2(1, 0),\n"
"    vec2(0, 0)\n"
");\n"
"\n"
"void main()\n"
"{\n"
"    // Extract vertex data\n"
"    vec2 vertex_pos = vec2(float(pos & 0xffffu), float(pos >> 16u)); \n"
"    vec2 vertex_tex = vec2(float(tex & 0xffffu), float(tex >> 16u));\n"
"    vec2 vertex_size = vec2(float(size & 0xffffu), float(size >> 16u));\n"
"\n"
"    // Compute vertex offset based on the vertex index\n"
"    vec2 vertex_offset = offsets[gl_VertexID];\n"
"\n"
"    // Apply offset and normalize\n"
"    vec2 position = (vertex_pos + vertex_size * vertex_offset) / vec2(viewport_size); \n"
"    position.y = 1 - position.y;\n"
"    gl_Position = vec4(position * 2 - 1, 0, 1);\n"
"\n"
"    // Set output\n"
"    uv = floor(vertex_tex + vertex_size * vertex_offset) / vec2(textureSize(texture0, 0));\n"
"}\n"
);
static const nu_sv_t shader_screen_blit_frag = NU_SV(
"#version 330 core\n"
"\n"
"out vec4 out_color;\n"
"in vec2 uv;\n"
"\n"
"uniform sampler2D t_surface;\n"
"\n"
"vec2 uv_filtering(in vec2 uv, in vec2 texture_size)\n"
"{\n"
"    vec2 pixel = uv * texture_size;\n"
"    vec2 seam = floor(pixel + 0.5);\n"
"    vec2 dudv = fwidth(pixel);\n"
"    vec2 rel = (pixel - seam) / dudv;\n"
"    vec2 mid_pix = vec2(0.5);\n"
"    pixel = seam + clamp(rel, -mid_pix, mid_pix);\n"
"    return pixel / texture_size;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    vec2 surface_size = textureSize(t_surface, 0);\n"
"    vec2 filtered_uv = uv_filtering(vec2(uv.x, 1 - uv.y), surface_size);\n"
"    out_color = texture(t_surface, filtered_uv);\n"
"}\n"
);
static const nu_sv_t shader_screen_blit_vert = NU_SV(
"#version 330 core\n"
"\n"
"out vec2 uv;\n"
"\n"
"void main()\n"
"{\n"
"    float x = float((gl_VertexID & 1) << 2);\n"
"    float y = float((gl_VertexID & 2) << 1);\n"
"\n"
"    uv.x = x * 0.5;\n"
"    uv.y = y * 0.5;\n"
"\n"
"    gl_Position = vec4(x - 1.0, y - 1.0, 0.0, 1.0);\n"
"}\n"
);
static const nu_sv_t shader_unlit_frag = NU_SV(
"#version 330 core\n"
"\n"
"out vec4 frag_color;\n"
"\n"
"uniform sampler2D texture0;\n"
"\n"
"layout(std140) uniform UBO {\n"
"    mat4 view;\n"
"    mat4 projection;\n"
"    vec4 color;\n"
"    vec4 fog_color;\n"
"    uvec2 viewport_size;\n"
"    float fog_density;\n"
"    float fog_near;\n"
"    float fog_far;\n"
"    bool is_volume;\n"
"};\n"
"\n"
"in VS_OUT {\n"
"    vec2 uv;\n"
"    vec4 color;\n"
"    float dist_cam;\n"
"    vec3 world_pos;\n"
"} fs_in;\n"
"\n"
"const float dither4x4[16] = float[16](\n"
"        0., 8., 2., 10.,\n"
"        12., 4., 14., 6.,\n"
"        3., 11., 1., 9.,\n"
"        15., 7., 13., 5.\n"
"    );\n"
"\n"
"const float dither8x8[64] = float[64](\n"
"        0., 32., 8., 40., 2., 34., 10., 42.,\n"
"        48., 16., 56., 24., 50., 18., 58., 26.,\n"
"        12., 44., 4., 36., 14., 46., 6., 38.,\n"
"        60., 28., 52., 20., 62., 30., 54., 22.,\n"
"        3., 35., 11., 43., 1., 33., 9., 41.,\n"
"        51., 19., 59., 27., 49., 17., 57., 25.,\n"
"        15., 47., 7., 39., 13., 45., 5., 37.,\n"
"        63., 31., 55., 23., 61., 29., 53., 21.\n"
"    );\n"
"\n"
"const int SCATTER_POINT_COUNT = 4;\n"
"const int OPTICAL_DEPTH_POINT_COUNT = 4;\n"
"const float FLT_MAX = 10000.0f;\n"
"const vec3 sun_position = vec3(1000);\n"
"const vec3 planet_center = vec3(0);\n"
"const float planet_radius = 50.0;\n"
"const float atmosphere_radius = 100;\n"
"const vec3 scatter_rgb = vec3(0.8, 0.8, 1);\n"
"const float density_falloff = 5;\n"
"\n"
"vec2 ray_sphere(\n"
"    in vec3 ray_origin,\n"
"    in vec3 ray_direction,\n"
"    in vec3 sphere_center,\n"
"    in float sphere_radius\n"
") {\n"
"    vec3 offsett = ray_origin - sphere_center;\n"
"    float a = 1.0; // dot(ray_direction, rayDirection);\n"
"    float b = 2.0 * dot(offsett, ray_direction);\n"
"    float c = dot(offsett, offsett) - sphere_radius * sphere_radius;\n"
"    float d = b * b - 4.0 * a * c; // Discriminant from quadratic formula\n"
"\n"
"    // d < 0 => 0 point\n"
"    // d = 1 => 1 point\n"
"    // d > 0 => 2 points\n"
"    if (d > 0.0) {\n"
"        float s = sqrt(d);\n"
"        float dst_to_sphere_near = max(0.0, (-b - s) / (2.0 * a));\n"
"        float dst_to_sphere_far = (-b + s) / (2.0 * a);\n"
"\n"
"        // Ignore intersections behind the ray\n"
"        if (dst_to_sphere_far >= 0.0) {\n"
"            return vec2(dst_to_sphere_near, dst_to_sphere_far - dst_to_sphere_near);\n"
"        }\n"
"    }\n"
"\n"
"    // No intersection\n"
"    return vec2(FLT_MAX, 0.0);\n"
"}\n"
"\n"
"float density_at_point(\n"
"    in vec3 density_sample_point\n"
") {\n"
"    float height_above_surface = length(density_sample_point - planet_center) - planet_radius;\n"
"    float height01 = height_above_surface / (atmosphere_radius - planet_radius);\n"
"    float local_density = exp(-height01 * density_falloff) * (1.0 - height01);\n"
"    return local_density;\n"
"}\n"
"\n"
"float optical_depth(\n"
"    in vec3 ray_origin,\n"
"    in vec3 ray_direction,\n"
"    in float ray_length\n"
") {\n"
"    vec3 density_sample_point = ray_origin;\n"
"    float step_size = ray_length / float(OPTICAL_DEPTH_POINT_COUNT - 1);\n"
"    float optical_depth = 0.0;\n"
"\n"
"    for (int i = 0; i < OPTICAL_DEPTH_POINT_COUNT; i++) {\n"
"        float localDensity = density_at_point(density_sample_point);\n"
"        optical_depth += localDensity * step_size;\n"
"        density_sample_point += ray_direction * step_size;\n"
"    }\n"
"\n"
"    return optical_depth;\n"
"}\n"
"\n"
"vec4 calculate_light(\n"
"    in vec3 ray_origin,\n"
"    in vec3 ray_direction,\n"
"    in float ray_length,\n"
"    in vec3 original_color\n"
") {\n"
"    vec3 dir_to_sun = normalize(sun_position - planet_center);\n"
"    vec3 scatter_point = ray_origin;\n"
"    float step_size = ray_length / float(SCATTER_POINT_COUNT - 1);\n"
"    vec3 scatter_light = vec3(0.0, 0.0, 0.0);\n"
"\n"
"    float view_ray_optical_depth = 0.0;\n"
"    for (int i = 0; i < SCATTER_POINT_COUNT; i++) {\n"
"        // float sun_ray_length = ray_sphere(scatter_point, dir_to_sun, planet_center, atmosphere_radius).y;\n"
"        // float sun_ray_optical_depth = optical_depth(scatter_light, dir_to_sun, sun_ray_length);\n"
"        view_ray_optical_depth = optical_depth(scatter_point, -ray_direction, step_size * float(i));\n"
"        float local_density = density_at_point(scatter_point);\n"
"        // vec3 transmittance = exp(-(sun_ray_optical_depth + view_ray_optical_depth) * scatter_rgb);\n"
"\n"
"        // scatter_light += local_density * step_size * transmittance * scatter_rgb;\n"
"        scatter_light += local_density * step_size * 0.02 * scatter_rgb;\n"
"        scatter_point += ray_direction * step_size;\n"
"    }\n"
"\n"
"    float original_color_transmittance = exp(-view_ray_optical_depth);\n"
"    // return original_color_transmittance * original_color + scatter_light;\n"
"    return vec4(scatter_light, 1 - original_color_transmittance);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    if (is_volume)\n"
"    {\n"
"        // vec3 original_color = texture2D(colorBuffer, gl_FragCoord.xy / resolution.xy).xyz;\n"
"        vec3 original_color = vec3(0);\n"
"        // const vec3 planet_center = vec3(0);\n"
"        // const float planet_radius = 50;\n"
"        // const float atmosphere_radius = 60;\n"
"\n"
"        vec3 view_pos = vec3(inverse(view) * vec4(0, 0, 0, 1));\n"
"        // vec3 view_pos = vec3(transpose(view) * vec4(0, 0, 0, 1));\n"
"\n"
"        vec3 ray_origin = view_pos;\n"
"        vec3 ray_dir = normalize(fs_in.world_pos.xyz - view_pos);\n"
"\n"
"        vec2 planet_hit_info = ray_sphere(ray_origin, ray_dir, planet_center, planet_radius);\n"
"        vec2 atmosphere_hit_info = ray_sphere(ray_origin, ray_dir, planet_center, atmosphere_radius);\n"
"\n"
"        float dst_to_surface = planet_hit_info.x;\n"
"        float dst_to_atmosphere = atmosphere_hit_info.x;\n"
"        float dst_through_atmosphere = min(atmosphere_hit_info.y, dst_to_surface - dst_to_atmosphere);\n"
"\n"
"        if (dst_through_atmosphere > 0.0) {\n"
"            const float epsilon = 0.0001;\n"
"            vec3 point_in_atmosphere = ray_origin + ray_dir * (dst_to_atmosphere + epsilon);\n"
"            vec4 light = calculate_light(point_in_atmosphere, ray_dir, dst_through_atmosphere - epsilon * 2.0, original_color);\n"
"\n"
"            frag_color = light;\n"
"        } else {\n"
"            frag_color = vec4(0);\n"
"        }\n"
"    }\n"
"    else\n"
"    {\n"
"        vec4 color = texture(texture0, fs_in.uv) * fs_in.color;\n"
"        float fog = clamp((fs_in.dist_cam - fog_near) / (fog_far - fog_near), 0, 1) * fog_density;\n"
"        int x = int(gl_FragCoord.x) % 8;\n"
"        int y = int(gl_FragCoord.y) % 8;\n"
"        float thres = (1 + dither8x8[x + y * 8]) / 64.;\n"
"        color.w *= (1 - fog);\n"
"        if (color.w >= thres)\n"
"            frag_color = mix(color, vec4(fog_color.xyz, 1), fog);\n"
"        else\n"
"            discard;\n"
"    }\n"
"}\n"
);
static const nu_sv_t shader_unlit_vert = NU_SV(
"#version 330 core\n"
"\n"
"layout(location = 0) in vec3 in_position;\n"
"layout(location = 1) in vec2 in_uv;\n"
"layout(location = 2) in vec3 in_color;\n"
"\n"
"layout(std140) uniform UBO {\n"
"    mat4 view;\n"
"    mat4 projection;\n"
"    vec4 color;\n"
"    vec4 fog_color;\n"
"    uvec2 viewport_size;\n"
"    float fog_density;\n"
"    float fog_near;\n"
"    float fog_far;\n"
"    bool is_volume;\n"
"};\n"
"\n"
"uniform mat4 model;\n"
"\n"
"out VS_OUT {\n"
"    vec2 uv;\n"
"    vec4 color;\n"
"    float dist_cam;\n"
"    vec3 world_pos;\n"
"} vs_out;\n"
"\n"
"vec4 snap_vertex(in vec4 position)\n"
"{\n"
"    vec2 grid = vec2(viewport_size);\n"
"    position.xy = position.xy / position.w;\n"
"    position.xy = (floor(grid * position.xy) + 0.5) / grid;\n"
"    position.xy *= position.w;\n"
"    return position;\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    vec4 world_pos = model * vec4(in_position, 1);\n"
"    vs_out.world_pos = world_pos.xyz;\n"
"    vec4 view_pos = view * world_pos;\n"
"    vs_out.dist_cam = length(view_pos);\n"
"    vec4 position = projection * view_pos;\n"
"    gl_Position = snap_vertex(position);\n"
"\n"
"    vs_out.uv = in_uv;\n"
"    vs_out.color = vec4(in_color, 1) * color;\n"
"}\n"
);
static const nu_sv_t shader_volume_frag = NU_SV(
"#version 330 core\n"
"\n"
"void main() {\n"
"    vec3 originalColor   = texture2D(colorBuffer, gl_FragCoord.xy / resolution.xy).xyz;\n"
"    // float depthNonLinear = texture2D(depthBuffer, gl_FragCoord.xy / resolution.xy).r;\n"
"    // float depth          = linearizeDepth(depthNonLinear, 0.1, 1000.0);\n"
"\n"
"    vec3 rayOrigin    = cameraPosition;\n"
"    vec3 rayDirection = normalize(vertexWorldPosition.xyz - cameraPosition);\n"
"\n"
"    vec2 planetHitInfo     = raySphere(rayOrigin, rayDirection, planetCenter, planetRadius);\n"
"    vec2 atmosphereHitInfo = raySphere(rayOrigin, rayDirection, planetCenter, atmosphereRadius);\n"
"\n"
"    // float dstToSurface         = min(depth, planetHitInfo.x);\n"
"    float dstToSurface         = planetHitInfo.x;\n"
"    float dstToAtmosphere      = atmosphereHitInfo.x;\n"
"    float dstThroughAtmosphere = min(atmosphereHitInfo.y, dstToSurface - dstToAtmosphere);\n"
"\n"
"    if (dstThroughAtmosphere > 0.0) {\n"
"        const float epsilon    = 0.0001;\n"
"        vec3 pointInAtmosphere = rayOrigin + rayDirection * (dstToAtmosphere + epsilon);\n"
"        vec3 light             = calculateLight(pointInAtmosphere, rayDirection, dstThroughAtmosphere - epsilon * 2.0, originalColor);\n"
"    \n"
"        gl_FragColor = vec4(light, 1.0);\n"
"    } else {\n"
"        gl_FragColor = vec4(0, 0, 0, 0);\n"
"    }       \n"
"}\n"
);
static const nu_sv_t shader_volume_vert = NU_SV(
"#version 330 core\n"
"\n"
"out vec2 uv;\n"
"\n"
"void main()\n"
"{\n"
"    float x = float((gl_VertexID & 1) << 2);\n"
"    float y = float((gl_VertexID & 2) << 1);\n"
"\n"
"    uv.x = x * 0.5;\n"
"    uv.y = y * 0.5;\n"
"\n"
"    gl_Position = vec4(x - 1.0, y - 1.0, 0.0, 1.0);\n"
"}\n"
);
